[{"content":"在程序源文件里输入了一个字符串你好,\n","permalink":"https://hkeepl.github.io/posts/420004/","summary":"在程序源文件里输入了一个字符串你好,","title":"使用 Visual Studio 开发程序时的字符串编码问题"},{"content":"多人团队开发中，通常我们需要对提交的代码进行格式统一化，或者对提交的代码进行预编译，只有编译通过的代码才能上传到服务器。钩子脚本（hooks）正是实现这些功能的工具。\nhooks 是什么？ 根据特定的 SVN 操作（如提交（commit）、加锁（get-lock)和释放锁（release-lock)等），SVN 会在处理这些操作时调用对应的 hooks。这些 hooks 可以由用户自行编写，实现特定的功能。\nhooks 可以在服务器上使用，也可以在每个程序员的客户端上使用。服务器端的 hooks 具有完整的功能，而客户端只有部分功能（Git）或者不能使用钩子（SVN），因此下面主要研究服务端 hooks 的使用。\nhooks 脚本 打开一个 SVN 代码管理仓库的服务器文件夹（或者自己新建一个服务器文件夹）可以看到在 hooks 文件夹下有如下 hooks 模板文件：\npost-commit.tmpl post-lock.tmpl post-revprop-change.tmpl post-unlock.tmpl pre-commit.tmpl pre-lock.tmpl pre-revprop-change.tmpl pre-unlock.tmpl start-commit.tmpl 未来使用这些脚本，在 Windows 系统中需要将后缀修改为.bat，在 Linux 中需要修改为.sh。我们可以在这些文件中重新编写脚本，实现特定的功能。\n注意：hooks 模板文件是对应的 Linux 系统，模板文件在 Windows 下是不能运行的，比如在 pre-commit.tmpl 中，获取传入参数的命令在 Windows 下应该修改为：\nSET REPOS=%1 SET TXN=%2 svnlook 命令 svnlook 命令时 SVN 提供的一个命令行工具，用于查看仓库的信息，如提交日志、修改历史和文件属性等。\n常用的 svnlook 命令如下：\nsvnlook changed: 显示指定版本的提交的文件和目录的变化。 svnlook cat: 显示提交文件的具体内容。 为了简单起见，下面只介绍 hooks 最常用的一个脚本：pre-commit。\npre-commit 当客户端执行 commit 时，服务器会调用该脚本，脚本结束时返回 0 则可以提交，返回非 0 则终止此次提交。\n输入参数：\nREPOS，对应仓库的路径 TXN，对应提交的版本号 因为我对 Python 脚本比较熟悉，命令行程序敲起来头疼，所以我就在 bat 文件中调用 Python 脚本实现钩子功能了。\nSET REPOS=%1 SET TXN=%2 python path_to_your_python_script.py %REPOS% %TXN% 使用 Python 脚本 使用 Python 脚本实现如下功能：\n从服务器仓库克隆出仓库的一个完整副本 获取提交的目录和文件，将它们更新到副本文件夹中 在副本文件夹中执行程序的编译、测试等，成功返回 0，失败则返回非 0(脚本中未实现) import os, sys from subprocess import check_output import shutil repos = sys.argv[1] txn = sys.argv[2] temp_dir = \u0026#39;E:/temp\u0026#39; repo_url = \u0026#39;\u0026#39; def checkout_repo(): if os.path.exists(temp_dir): shutil.rmtree(directory_path) cmd = \u0026#39;svn checkout %s %s\u0026#39; % (repo_url, temp_dir) check_output(cmd) def commit_changes(): cmd = (\u0026#39;svnlook\u0026#39;, \u0026#39;changed\u0026#39;, repos, \u0026#39;-t\u0026#39;, txn) out = check_output(cmd).splitlines() for line in out: line = line.decode() yield line.split() checkout_repo() for status, path in commit_changes(): if path[-1] == \u0026#34;/\u0026#34;: target_dir = os.path.join(temp_dir, path) if not os.path.exists(target_dir): os.makedirs(target_dir) else: cmd = \u0026#39;svnlook cat -t %s %s %s\u0026#39; % (txn, repos, path) file_content = check_output(cmd) file_content = file_content.decode(\u0026#39;utf-8\u0026#39;) target_filename = os.path.join(temp_dir, path) with open(target_filename, \u0026#39;w\u0026#39;, encodeing=\u0026#39;utf-8\u0026#39;) as f: f.write(file_content) 总结 SVN 钩子脚本可以在我们对仓库进行某些操作时调用一些自定义的脚本，扩展了版本管理软件功能，能够有效的提高开发的效率，保证代码质量。\n","permalink":"https://hkeepl.github.io/posts/420003/","summary":"多人团队开发中，通常我们需要对提交的代码进行格式统一化，或者对提交的代码进行预编译，只有编译通过的代码才能上传到服务器。钩子脚本（hooks","title":"SVN 钩子使用介绍"},{"content":"","permalink":"https://hkeepl.github.io/about/","summary":"","title":"关于"},{"content":"一直以来我都是把 VSCode 当作一个文本编辑器，查看、编辑文本用。突然有一天发现在公司电脑上用 VSCode 编写代码不会被加密，又因为使用 CMake 编译 Qt 工程时需要文件是不加密的（应该是 moc 程序没有加入到公司加密程序列表里，只要头文件中有 Q_OBJECT 的声明，就不行），于是考虑在 VSCode 中编写代码，利用插件生成 VS 工程，编译代码，调试程序等等一些过程。\n需要安装的软件 Visual Studio。当然也可以选择其他的编译器，比如：mingw。 VSCode CMake 需要安装的 VSCode 插件 C/C++ CMake CMake Tools 编写一个最小的 CMake 工程 # CMakeLists.txt cmake_minimum_required(VERSION 3.18) project(HelloWorld CXX) add_executable(hello-world main.cpp) #include \u0026lt;iostream\u0026gt; int main(int argc, char *argv[]) { if(argc \u0026gt; 1) { std::cout \u0026lt;\u0026lt; argv[1] \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;Hello world.\u0026#34; \u0026lt;\u0026lt; std::endl; } 在 VSCode 中配置程序 在 VSCode 中按下 CTRL+SHIFT+P，选择 CMake 配置，在弹出的对话框中选择编译器，待 CMake 配置完成后，输出\n注意：VSCode 会自动在当前文件夹下新建一个 build 文件夹，里面用于存放 CMake 的配置输出。\n选择状态栏的 Build 按钮，进行编译\n成功后，我们就可以运行程序了！\n点击下方的 Launch the selecte target，就可以运行程序了（PS，如果有多个可执行文件，也可以在这里选择其他的目标工程运行）。\n在 VSCode 中调式程序 本文的重点来了。我们该怎么在 VSCode 中调试程序呢？\n其实，很简单，借助于 CMake Tools 工具，我们只需要在代码中添加断点，点击任务栏的调试（Debug）按钮就可以进行调试了。\n但是，但是，这种调试方式，我们不能输入任何命令行参数！该怎么办呢？\n答案是：使用 VSCode 的调试配置。\n在 .vscode 文件夹下，新建一个 launch.json 文件，并将下面的内容输入到文件中。\n{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问：https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;(msvc) Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppvsdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${command:cmake.launchTargetPath}\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceRoot}\u0026#34;, \u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;PATH\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;${env:PATH}:${command.cmake.getLaunchTargetDirectory}\u0026#34; } ], \u0026#34;console\u0026#34;: \u0026#34;externalTerminal\u0026#34; } ] } 在菜单栏选择 运行-\u0026gt;启动调试，便可以调试程序了。\n这里，我尝试输入一个参数，即修改上面配置文件的 args字段：\n\u0026#34;args\u0026#34;: [\u0026#34;You are welcome.\u0026#34;], 运行调试程序，输出：\n终于，过程通了！\n参考 CMake Tools for Visual Studio Code documentation ","permalink":"https://hkeepl.github.io/posts/420002/","summary":"一直以来我都是把 VSCode 当作一个文本编辑器，查看、编辑文本用。突然有一天发现在公司电脑上用 VSCode 编写代码不会被加密，又因为使用 CMake 编译 Qt 工程时需要文件是","title":"使用VSCode和CMake开发C++程序"},{"content":"CMake 是一个开源的 C++构建工具生成器，可以很方便的实现跨平台编译，解决 C++库之间的依赖关系。只需要配置 CMakeList.txt 文件就可以实现对 C++源代码构建的控制，而且还是库平台，简直太好用。下面记录了一些常用的 CMake 命令。\n命令模式 平台无关的系统命令，用法示例\n# 对 my.txt 文件，生成 md5 cmake -E md5sum my.txt 查看更多命令可以直接输入 cmake -E。\nCTest https://www.bookset.io/read/CMake-Cookbook/content-chapter4-4.1-chinese.md\n设置 MSVC 编译器编译 utf8 编码格式的源文件 add_compile_options(\u0026#34;$\u0026lt;$\u0026lt;C_COMPILER_ID:MSVC\u0026gt;:/utf-8\u0026gt;\u0026#34;) add_compile_options(\u0026#34;$\u0026lt;$\u0026lt;CXX_COMPILER_ID:MSVC\u0026gt;:/utf-8\u0026gt;\u0026#34;) 禁用特定警告 add_compile_options(“/wd4819”) 安装库 function(INSTALL_PROJECT) install(DIRECTORY \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/include\u0026#34; DESTINATION \u0026#34;include\u0026#34; OPTIONAL) install(TARGETS ${ARGN} CONFIGURATIONS Debug RUNTIME DESTINATION \u0026#34;bin_debug\u0026#34; LIBRARY DESTINATION \u0026#34;lib_debug\u0026#34; ARCHIVE DESTINATION \u0026#34;lib_debug\u0026#34;) install(TARGETS ${ARGN} CONFIGURATIONS Release RUNTIME DESTINATION \u0026#34;bin\u0026#34; LIBRARY DESTINATION \u0026#34;lib\u0026#34; ARCHIVE DESTINATION \u0026#34;lib\u0026#34;) # install target pdb install(FILES $\u0026lt;TARGET_PDB_FILE:${ARGN}\u0026gt; CONFIGURATIONS Release DESTINATION \u0026#34;bin\u0026#34; OPTIONAL) endfunction() 导入第三方库 这里针对已经只有头文件的库，已经编译好的非 CMake 工程库，和 CMake 工程库。\n方式 1 set(EIGEN3_DIR \u0026#34;path_to_eigen_cmake\u0026#34;) if(NOT EXISTS \u0026#34;${EIGEN3_DIR}\u0026#34;) set(EIGEN3_DIR \u0026#34;\u0026#34;) endif() find_package(EIGEN3 REQUIRED) if(NOT EIGEN3_FOUND) message(STATUS \u0026#34;Warning: Eigen was not found.\u0026#34;) else() message(STATUS \u0026#34;Info: Eigen was found.) include_directories(${EIGEN3_INCLUDE_DIR}) endif() file(GLOB PLOG_DIR \u0026#34;path/plog*\u0026#34;) find_path(WITH_PLOG_INC \u0026#34;include/plog/Log.h\u0026#34; \u0026#34;${PLOG_DIR}\u0026#34; NO_DEFAULT_PATH) if(WITH_PLOG_INC) set(PLOG_INCLUDE_DIRS \u0026#34;${WITH_PLOG_INC}/include\u0026#34;) include_directories(${PLOG_INCLUDE_DIRS}) else() message(STATUS \u0026#34;Warning: plog was not found.\u0026#34;) endif() set(Protobuf_SRC_ROOT_FOLDER \u0026#34;path_protobuf_dir\u0026#34;) if(NOT EXISTS \u0026#34;${Protobuf_SRC_ROOT_FOLDER}\u0026#34;) set(Protobuf_SRC_ROOT_FOLDER \u0026#34;\u0026#34;) endif() find_package(Protobuf_SRC_ROOT_FOLDER REQUIRED) if(NOT Protobuf_SRC_ROOT_FOLDER_FOUND) message(STATUS \u0026#34;Warning: Protobuf was not found.\u0026#34;) else() message(STATUS \u0026#34;Info: Protobuf was found.) include_directories(${Protobuf_INCLUDE_DIRS}) endif() 方式 2 使用 CMAKE_PREFIX_PATH\nif(WIN32 AND MSVC) if(CMAKE_SIZEOF_VOID_P EQUAL 8) set(QT_PATH \u0026#34;qt_path\u0026#34; CACHE PATH \u0026#34;Qt path\u0026#34;) endif() set(CMAKE_PREFIX_PATH \u0026#34;${QT_PATH}\u0026#34;) mark_as_advance(QT_PATH) endif() find_package(Protobuf REQUIRED) if(NOT Protobuf_FOUND) message(STATUS \u0026#34;Warning: Protobuf was not found.\u0026#34;) else() message(STATUS \u0026#34;Info: Protobuf was found.\u0026#34;) include_directories(${Protobuf_INCLUDE_DIRS}) endif() Qt 翻译文件 https://gitlab.kitware.com/cmake/cmake/-/issues/21549\nMACRO 和 FUNCTION https://blog.csdn.net/weixin_34121282/article/details/87972772\nhttps://www.jianshu.com/p/6be3b104ab70\n共同点 形式基本相同。\nmarco 形式如下：\nmacro(\u0026lt;name\u0026gt; [arg1 [arg2 [arg3 ...]]]) COMMAND1(ARGS ...) COMMAND2(ARGS ...) endmacro() function 形式如下：\nfunction(\u0026lt;name\u0026gt; [arg1 [arg2 [arg3 ...]]]) COMMAND1(ARGS ...) COMMAND2(ARGS ...) endfunction() 变量的引用：\n变量 说明 ARGV# 同上 ARGV 所有定义时要求传入的参数 ARGN 定义时要求输入的参数以外的参数，比如定义时要求输入 1 个参数，实际输入了 3 个，那么后面两个参数保存在 ARGN 中 ARGC 传入的实际参数个数 设置构建 toolset 在高版本的 Visual Studio 可以使用低版本的 toolset 进行编译，比如，vs2019，安装了 vs2017 的构建工具和 sdk 后可以使用 vs2017 构建 cmake 项目。\n# 设置 generator -G \u0026#34;Visual Studio 15 2017\u0026#34; # 设置 toolset -T v141 设置输出目录 set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_BINDIR}\u0026#34;) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR}\u0026#34;) set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \u0026#34;${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR}\u0026#34;) 设置工程调试的工作目录 VS_DEBUGGER_WORKING_DIRECTORY 设置工程属性 输出文件名 set_target_properties(LibraryA PROPERTIES OUTPUT_NAME \u0026#34;my_LibraryA\u0026#34;) 预处理器定义 set_target_properties(LibraryA PROPERTIES COMPILE_DEFINITIONS \u0026#34;LibraryA_EXPORTS\u0026#34;) 工程分组 根目录设置：\nset_property(GLOBAL PROPERTY USE_FOLDERS ON) 每个分组下工程设置：\nset_target_properties(LibraryA PROPERTIES FOLDER \u0026#34;Utilities\u0026#34;) set_target_properties(LibraryB PROPERTIES FOLDER \u0026#34;Utilities\u0026#34;) 源文件分组 source_group(\u0026#34;game\\\\entitysystem\\\\components\u0026#34; FILES ${components_SRC}) 设置 Windows Qt 工程不弹出命令行窗口 #-------------------------------------------------------------------- # Hide the console window in visual studio projects #-------------------------------------------------------------------- if(MSVC) set(CMAKE_EXE_LINKER_FLAGS \u0026#34;${CMAKE_EXE_LINKER_FLAGS} /SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup\u0026#34;) endif() #-------------------------------------------------------------------- # Hide the console window in visual studio projects - Release #-------------------------------------------------------------------- if(MSVC) set(CMAKE_EXE_LINKER_FLAGS_RELEASE \u0026#34;${CMAKE_EXE_LINKER_FLAGS} /SUBSYSTEM:WINDOWS /ENTRY:mainCRTStartup\u0026#34;) endif() INCLUDE_DIRECTORIES作用域 The include directories are added to the INCLUDE_DIRECTORIES directory property for the current CMakeLists file. They are also added to the INCLUDE_DIRECTORIES target property for each target in the current CMakeLists file.\nset用法 set赋值给一般变量 仅在所在的作用域起作用。除非后面使用 PARENT_SCOPE。举例\n// foo 作用域为当前作用域 set(foo \u0026#34;X\u0026#34;) // foo 作用域是当前文件的上一目录的 CMakeList set(foo \u0026#34;x\u0026#34; PARENT_SCOPE) set赋值给缓存变量 第一次运行 cmake 时，这些变量缓存到 CMakeCache.txt 中，在整个 cmake 运行过程中都可以起作用。\n当使用 CACHE 时，且缓存中没有该变量时，变量被创建并且存入缓存中，如果原缓存中有该变量，也不会改变原缓存中该变量的值，除非后面使用 FORCE。\n// 原缓存中没有 foo，则将 foo 赋值为 x，且存入缓存 // 原缓存中有 foo，则不做改变 set(foo \u0026#34;x\u0026#34; CACHE \u0026lt;type\u0026gt; \u0026lt;docstring\u0026gt;) // 即使原缓存中存在 foo，也会重新设置 foo set(foo \u0026#34;x\u0026#34; CACHE \u0026lt;type\u0026gt; \u0026lt;docstring\u0026gt; FORCE) 使用 CACHE 时，要设定\u0026lt;type\u0026gt;和docstring。\ntype description FILEPATH File chooser dialog. PATH Directory chooser dialog. STRING Arbitrary string. BOOL Boolean ON/OFF checkbox. INTERNAL No GUI entry (used for persistent variables). 可以通过 CMake 变量声明另一个变量 set(${macroparam}_LOCATION “”) 在 CMakeList 文件中使用\nmessage(STATUS ${${macroparam}_LOCATION}) 设置后缀 set(CMAKE_DEBUG_POSTFIX \u0026#34;_d\u0026#34;) ","permalink":"https://hkeepl.github.io/posts/420001/","summary":"CMake 是一个开源的 C++构建工具生成器，可以很方便的实现跨平台编译，解决 C++库之间的依赖关系。只需要配置 CMakeList.txt 文件就可以实现对 C++源代码构建的控","title":"CMake 开发经验"}]